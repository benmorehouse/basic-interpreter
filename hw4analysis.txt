1. Analyze the running time for figuring out which line a GOTO, GOSUB, IF jumps to. (That is, going from having the line number to actually knowing what command is on that line.) 

Firstly let's look at the overall structure of the assignment. 
If you look specifically in Compiler.cpp, you will notice that the first line in main calls [bool] Compiler::parsefile(). This takes an o(n) run through of the file that is input into the interpreter, and in doing so, will do two major things. specifically look at these two lines:

		this->lineNumbers.push_back(linenumber);
		this->commandList[linenumber] = buffer;
We push_back to the end of a vector within the compiler class (o(1)) and also insert the line of BASIC code into a map(o(log n)).
Thus within the first line of main for the compiler we have a vector and a map that we will use throughout the program. It was essentially to have these two data structures for reasons that will become evident later on in the program.

After this within main, we have a while loop at line 25, which we know will average out to be around o(n) runtime if not less based on the gosub commands and what not. 

Within each loop we use a function called getCommand @ line 315 of compiler.cpp. This essentially checks to see which command we are using. We specifically will access from the map that we made earlier to get the line at int cursor position. This will be o(log (n)) runtime.

At this point we have a general analysis of what each step takes.
Now onto understanding the GOTO function. After creating the numeric expression for the actual line, which in most case scenarios is just o(1) because we pass in a constant, we call on a function called jumpToCommand. Please go to line 338. 

Here I have created an iterator that will iterate over the vector that held the numbers for each of these lines.This will be a worst case scenario runtime of o(n). Possibly better ways to architect this problem I believe. perhaps the ability to push all commands int a map of type <int, string> would work and give us a o(log n) runtime, but i had a lot of trouble being able to execute the rest of the homework by trying to implement this.

Next we have the GOSUB which again uses this same Jumptocommand. The gosub emulates the same sort of runtime as the goto because of my implementation of the stack that can tell us where our last GOSUB was (this is used for the return command of course).



2. This gives us a good introduction to the return function. We use the same jumptoCommand function, which is o(n) runtime, and an o(1) runtime for a total of an o(n) runtime for the return statement. To better see this, please go to 156 of Compiler.cpp. this will show you in this code block that we check the top, and then get the value off the top of the stack for the next line. 

3. To change the value of one of the variables or assign it into the map that we have made, lets look at line 50 of the compiler.cpp part of the assignment. In this part, we can see that we insert into the map and change the map at the same runtime. 
Here is an example:

	this->variableValues[varName] = this->interpreter->parseNumericExpression(temp,i)->getFinalValue();

Accessing this map index will give us a good runtime and it was the main reason that i chose it for the architecture of my assignment

4. i unfortunately was not able to correctly implement my array functionality, but I would say that the best way to implement an array in this scenario would be to have a seperate map, with each key being the name of the array and the value being a vector. That way when we have several vectors, we can access the vector itself in an o(log n) runtime, and then can access the vector in an o(1) runtime. If we want to add to this vector within this map, it is simply an o(1) process.

I hope to be able to go back after this assignment is due and be able to fix my mistakes. It was a really fun project and I am excited to have been able to build it!!

 
